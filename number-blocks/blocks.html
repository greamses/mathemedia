<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base 10 Blocks - Interactive Learning</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Nunito:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  /* PBS Kids Style Math Blocks CSS */

/* Google Fonts Import */
@import url('https://fonts.googleapis.com/css2?family=Fredoka+One:wght@400&family=Nunito:wght@400;600;700;800&display=swap');

/* Material Icons Import */
@import url('https://fonts.googleapis.com/icon?family=Material+Icons');

/* Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Fredoka One', 'Nunito', Arial, sans-serif;
    min-height: 100vh;
    padding: 20px;
    color: #2C3E50;
    position: relative;
}

/* Animated background dots */
body::before {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 20%, #FFE4B5 2px, transparent 2px),
        radial-gradient(circle at 80% 80%, #98FB98 2px, transparent 2px),
        radial-gradient(circle at 40% 60%, #FFB6C1 2px, transparent 2px),
        radial-gradient(circle at 60% 40%, #DDA0DD 2px, transparent 2px);
    background-size: 100px 100px, 120px 120px, 80px 80px, 90px 90px;
    animation: floatDots 20s linear infinite;
    z-index: 1;
    pointer-events: none;
}

@keyframes floatDots {
    0% { transform: translateY(0px); }
    50% { transform: translateY(-20px); }
    100% { transform: translateY(0px); }
}

/* Container */
.container {
    max-width: 1200px;
    margin: 0 auto;
    background-color: #FFFFFF;
    border-radius: 25px;
    overflow: hidden;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
    border: 6px solid #FF6B6B;
    position: relative;
    z-index: 2;
}

/* Header */
.header {
    background-color: #4ECDC4;
    color: #FFFFFF;
    padding: 30px 20px;
    text-align: center;
    border-bottom: 6px solid #45B7AA;
    position: relative;
    overflow: hidden;
}

.header::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 10% 10%, rgba(255, 255, 255, 0.1) 15px, transparent 15px),
        radial-gradient(circle at 90% 90%, rgba(255, 255, 255, 0.1) 12px, transparent 12px),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.1) 8px, transparent 8px);
    background-size: 200px 200px, 180px 180px, 150px 150px;
    animation: bubbleFloat 15s linear infinite;
    z-index: 1;
}

@keyframes bubbleFloat {
    0% { transform: translateY(0px) rotate(0deg); }
    100% { transform: translateY(-30px) rotate(360deg); }
}

.header h1 {
    font-size: 2.8rem;
    font-weight: 400;
    margin-bottom: 10px;
    text-shadow: 3px 3px 0 #45B7AA;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    font-family: 'Fredoka One', cursive;
    position: relative;
    z-index: 2;
}

.header p {
    font-size: 1.3rem;
    font-weight: 600;
    max-width: 600px;
    margin: 0 auto;
    color: #F0FFFF;
    font-family: 'Nunito', sans-serif;
    position: relative;
    z-index: 2;
}

/* Difficulty Selector */
.difficulty-selector {
    margin-top: 20px;
    position: relative;
    z-index: 2;
}

.difficulty-selector select {
    padding: 12px 20px;
    font-size: 1.1rem;
    border: 4px solid #FF6B6B;
    border-radius: 20px;
    background: #FFFFFF;
    color: #FF6B6B;
    cursor: pointer;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}

.difficulty-selector select:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

/* Main Content Layout */
.main-content {
    display: flex;
    min-height: 600px;
    background-color: #F8F9FA;
}

/* Sidebar */
.sidebar {
    width: 300px;
    background-color: #FFE4B5;
    padding: 25px;
    border-right: 6px solid #F4D03F;
    position: relative;
}

.sidebar::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 15px;
    background: repeating-linear-gradient(
        90deg,
        #FF6B6B 0px,
        #FF6B6B 15px,
        #4ECDC4 15px,
        #4ECDC4 30px,
        #45B7AA 30px,
        #45B7AA 45px,
        #F4D03F 45px,
        #F4D03F 60px
    );
}

.sidebar h3 {
    color: #E67E22;
    margin-bottom: 20px;
    font-size: 1.5rem;
    display: flex;
    align-items: center;
    gap: 10px;
    padding-bottom: 10px;
    border-bottom: 4px dotted #F39C12;
    font-family: 'Fredoka One', cursive;
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
}

/* Block Controls */
.block-controls {
    margin-bottom: 25px;
}

.block-type {
    margin-bottom: 20px;
    padding: 20px;
    background-color: #FFFFFF;
    border-radius: 20px;
    border: 4px solid #DDA0DD;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.block-type::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: #DDA0DD;
}

.block-type h4 {
    color: #8E44AD;
    margin-bottom: 12px;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Fredoka One', cursive;
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
}

.block-input {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    font-weight: 700;
    color: #2C3E50;
    font-family: 'Nunito', sans-serif;
}

.block-input input {
    width: 70px;
    padding: 10px;
    border: 4px solid #FF6B6B;
    border-radius: 15px;
    text-align: center;
    font-size: 1.1rem;
    font-weight: 700;
    color: #E74C3C;
    font-family: 'Nunito', sans-serif;
    transition: all 0.3s ease;
}

.block-input input:focus {
    outline: none;
    border-color: #4ECDC4;
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.add-blocks-btn {
    background-color: #FF6B6B;
    color: #FFFFFF;
    border: none;
    padding: 12px 20px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
    font-family: 'Nunito', sans-serif;
    box-shadow: 0 6px 0 #E74C3C;
    width: 100%;
    justify-content: center;
}

.add-blocks-btn:hover {
    background-color: #E74C3C;
    transform: translateY(-2px);
    box-shadow: 0 8px 0 #C0392B;
}

.add-blocks-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #C0392B;
}

/* Place Value Display */
.place-value-display {
    background-color: #E8F8F5;
    padding: 20px;
    border-radius: 20px;
    margin-top: 20px;
    border: 4px solid #4ECDC4;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
}

.place-value-display h4 {
    color: #16A085;
    margin-bottom: 15px;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Fredoka One', cursive;
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
}

.value-breakdown {
    font-size: 1.1rem;
    line-height: 2;
    color: #2C3E50;
    font-weight: 600;
    font-family: 'Nunito', sans-serif;
}

.value-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 5px 0;
    margin-bottom: 8px;
    border-bottom: 2px dotted #4ECDC4;
}

.value-row:last-child {
    border-bottom: none;
}

.value-row span {
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Regroup Button Styles */
.regroup-btn {
    background-color: #9B59B6;
    color: #FFFFFF;
    border: none;
    padding: 8px 12px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 700;
    transition: all 0.3s ease;
    font-family: 'Nunito', sans-serif;
    box-shadow: 0 4px 0 #8E44AD;
    display: flex;
    align-items: center;
    gap: 5px;
}

.regroup-btn:hover {
    background-color: #8E44AD;
    transform: translateY(-1px);
    box-shadow: 0 5px 0 #7D3C98;
}

.regroup-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 0 #7D3C98;
}

.block.regrouping {
    animation: regroupPulse 0.8s ease-in-out;
    z-index: 10000 !important;
}

@keyframes regroupPulse {
    0% { transform: scale(1); }
    25% { transform: scale(1.15); filter: hue-rotate(90deg); }
    50% { transform: scale(1.25); filter: hue-rotate(180deg); }
    75% { transform: scale(1.15); filter: hue-rotate(270deg); }
    100% { transform: scale(1); filter: hue-rotate(360deg); }
}

.total-value {
    font-size: 2rem;
    font-weight: 800;
    color: #16A085;
    margin-top: 15px;
    text-align: center;
    padding: 15px;
    background-color: #FFFFFF;
    border-radius: 20px;
    border: 4px dotted #4ECDC4;
    font-family: 'Fredoka One', cursive;
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
    animation: numberPulse 2s ease-in-out infinite;
}

@keyframes numberPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

/* Canvas Area */
.canvas-area {
    flex: 1;
    padding: 25px;
    position: relative;
    background-color: #F8F9FA;
}

.canvas {
    width: 100%;
    height: 550px;
    border: 6px dashed #FF6B6B;
    border-radius: 25px;
    position: relative;
    background-color: #FFFFFF;
    transition: all 0.3s ease;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
}

.canvas.drag-over {
    border-color: #4ECDC4;
    background-color: #E8F8F5;
    transform: scale(1.02);
}

.canvas-label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #FF6B6B;
    font-size: 1.8rem;
    font-weight: 400;
    pointer-events: none;
    z-index: 1;
    text-align: center;
    width: 80%;
    font-family: 'Fredoka One', cursive;
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
}

.canvas-label i {
    font-size: 4rem;
    margin-bottom: 15px;
    display: block;
    color: #4ECDC4;
    animation: bounce 2s ease-in-out infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

/* Blocks */
.block {
    position: absolute;
    cursor: move;
    user-select: none;
    transition: all 0.3s ease;
    z-index: 10;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    border-radius: 12px;
    touch-action: none;
}

.block:hover {
    transform: scale(1.1);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
    z-index: 100;
}

.block.dragging {
    z-index: 1000;
    opacity: 0.9;
    transform: scale(1.15) rotate(5deg);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
}

/* Unit Block (1) */
.unit-block {
    width: 35px;
    height: 35px;
    background-color: #FF6B6B;
    border: 4px solid #E74C3C;
    border-radius: 10px;
    position: relative;
    overflow: hidden;
}

.unit-block::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(255, 255, 255, 0.2) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(255, 255, 255, 0.2) 75%);
    background-size: 8px 8px;
    background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
}

/* Ten Block (10) */
.ten-block {
    width: 220px;
    height: 35px;
    background-color: #4ECDC4;
    border: 4px solid #45B7AA;
    border-radius: 12px;
    position: relative;
    overflow: hidden;
}

.ten-block::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
        to right,
        rgba(255, 255, 255, 0.3),
        rgba(255, 255, 255, 0.3) 20px,
        transparent 20px,
        transparent 22px
    );
}

.ten-block::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%);
    background-size: 4px 4px;
}

/* Hundred Block (100) */
.hundred-block {
    width: 220px;
    height: 220px;
    background-color: #9045B7;
    border: 4px solid #BF83DE;
    border-radius: 15px;
    position: relative;
    overflow: hidden;
}

.hundred-block::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
        repeating-linear-gradient(
            to right,
            rgba(255, 255, 255, 0.2),
            rgba(255, 255, 255, 0.2) 20px,
            transparent 20px,
            transparent 22px
        ),
        repeating-linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.2),
            rgba(255, 255, 255, 0.2) 20px,
            transparent 20px,
            transparent 22px
        );
}

.hundred-block::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%);
    background-size: 6px 6px;
}

/* Thousand Block (1000) - 3D Cube */
.thousand-block {
    width: 220px;
    height: 220px;
    position: relative;
    transform-style: preserve-3d;
    transform: rotateX(-15deg) rotateY(15deg);
    animation: float 6s ease-in-out infinite;
}

.cube-face {
    position: absolute;
    width: 220px;
    height: 220px;
    border: 4px solid rgba(0, 0, 0, 0.1);
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    overflow: hidden;
    font-size: 0;
    background-size: 22px 22px;
    background-image:
        linear-gradient(to right, rgba(255, 255, 255, 0.7) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
}

.cube-front {
    background-color: #F4D03F;
    transform: translateZ(110px);
}

.cube-back {
    background-color: #F39C12;
    transform: rotateY(180deg) translateZ(110px);
}

.cube-right {
    background-color: #E67E22;
    transform: rotateY(90deg) translateZ(110px);
}

.cube-left {
    background-color: #D35400;
    transform: rotateY(-90deg) translateZ(110px);
}

.cube-top {
    background-color: #F7DC6F;
    transform: rotateX(90deg) translateZ(110px);
}

.cube-bottom {
    background-color: #F1C40F;
    transform: rotateX(-90deg) translateZ(110px);
}

@keyframes float {
    0%, 100% { transform: rotateX(-15deg) rotateY(15deg) translateY(0); }
    50% { transform: rotateX(-15deg) rotateY(15deg) translateY(-15px); }
}

/* Buttons */
.clear-btn {
    background-color: #E74C3C;
    color: #FFFFFF;
    border: none;
    padding: 15px 30px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    justify-content: center;
    transition: all 0.3s ease;
    font-family: 'Nunito', sans-serif;
    box-shadow: 0 6px 0 #C0392B;
}

.clear-btn:hover {
    background-color: #C0392B;
    transform: translateY(-3px);
    box-shadow: 0 9px 0 #A93226;
}

.clear-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #A93226;
}

/* Zoom Controls */
.zoom-controls {
    background-color: #FFFFFF;
    border-radius: 20px;
    padding: 20px;
    margin-bottom: 25px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    border: 4px solid #DDA0DD;
}

.zoom-controls h4 {
    margin: 0 0 15px 0;
    color: #8E44AD;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Fredoka One', cursive;
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
}

.zoom-buttons {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
}

.zoom-btn {
    background-color: #4ECDC4;
    color: #FFFFFF;
    border: none;
    padding: 10px 15px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.3s ease;
    font-family: 'Nunito', sans-serif;
    box-shadow: 0 4px 0 #45B7AA;
}

.zoom-btn:hover {
    background-color: #45B7AA;
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #16A085;
}

.zoom-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 0 #16A085;
}

.zoom-btn:disabled {
    background-color: #BDC3C7;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 4px 0 #95A5A6;
}

.zoom-level {
    font-weight: 700;
    color: #2C3E50;
    min-width: 50px;
    text-align: center;
    font-size: 1.1rem;
    font-family: 'Fredoka One', cursive;
}

/* Animations */
.block.deleting {
    animation: scaleDown 0.4s forwards;
}

@keyframes scaleDown {
    0% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.2) rotate(180deg); }
    100% { transform: scale(0) rotate(360deg); opacity: 0; }
}

/* Responsive Design */
@media (max-width: 768px) {
    .main-content {
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 6px solid #F4D03F;
    }
    
    .canvas {
        height: 450px;
    }
    
    .header h1 {
        font-size: 2.2rem;
    }
    
    .header p {
        font-size: 1.1rem;
    }
    
    body {
        padding: 10px;
    }
    
    .container {
        border-radius: 20px;
        border-width: 4px;
    }
}

/* Fun hover effects */
.material-icons {
    font-size: 28px;
    vertical-align: middle;
    transition: transform 0.3s ease;
}

.material-icons:hover {
    transform: rotate(360deg);
}

/* Success animations */
@keyframes success {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); background-color: #2ECC71; }
    100% { transform: scale(1); }
}

.block.success {
    animation: success 0.6s ease-in-out;
}
</style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="material-icons">calculate</i> Base 10 Blocks</h1>
            <p>Drag and drop blocks to build numbers and learn place value!</p>
            <div class="difficulty-selector">
                <select id="difficulty">
                    <option value="tens">Units to Tens</option>
                    <option value="hundreds">Units to Hundreds</option>
                    <option value="thousands">Units to Thousands</option>
                </select>
            </div>
        </div>
        
        <div class="main-content">
            <div class="sidebar">
                <h3><i class="material-icons">add_circle</i> Add Blocks</h3>
                
                <div class="block-controls">
                    <div class="block-type">
                        <h4><i class="material-icons">crop_square</i> Units (1)</h4>
                        <div class="block-input">
                            <input type="number" id="unit-count" min="0" max="50" value="1">
                            <button class="add-blocks-btn" onclick="addBlocks('unit')">
                                <i class="material-icons">add</i> Add
                            </button>
                        </div>
                    </div>
                    
                    <div class="block-type" id="ten-control">
                        <h4><i class="material-icons">more_horiz</i> Tens (10)</h4>
                        <div class="block-input">
                            <input type="number" id="ten-count" min="0" max="20" value="1">
                            <button class="add-blocks-btn" onclick="addBlocks('ten')">
                                <i class="material-icons">add</i> Add
                            </button>
                        </div>
                    </div>
                    
                    <div class="block-type" id="hundred-control">
                        <h4><i class="material-icons">grid_on</i> Hundreds (100)</h4>
                        <div class="block-input">
                            <input type="number" id="hundred-count" min="0" max="10" value="1">
                            <button class="add-blocks-btn" onclick="addBlocks('hundred')">
                                <i class="material-icons">add</i> Add
                            </button>
                        </div>
                    </div>
                    
                    <div class="block-type" id="thousand-control">
                        <h4><i class="material-icons">layers</i> Thousands (1000)</h4>
                        <div class="block-input">
                            <input type="number" id="thousand-count" min="0" max="5" value="1">
                            <button class="add-blocks-btn" onclick="addBlocks('thousand')">
                                <i class="material-icons">add</i> Add
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="place-value-display">
                    <h4><i class="material-icons">assessment</i> Place Value Matcher</h4>
                    <div class="value-breakdown" id="value-breakdown">
                        <div class="value-row">
                            <span><i class="material-icons">crop_square</i> Units: 0</span>
                        </div>
                        <div class="value-row">
                            <span><i class="material-icons">more_horiz</i> Tens: 0</span>
                        </div>
                        <div class="value-row">
                            <span><i class="material-icons">grid_on</i> Hundreds: 0</span>
                        </div>
                        <div class="value-row">
                            <span><i class="material-icons">layers</i> Thousands: 0</span>
                        </div>
                    </div>
                    <div class="total-value" id="total-value">Total: 0</div>
                </div>
                
                <button class="clear-btn" onclick="clearCanvas()">
                    <i class="material-icons">delete</i> Clear All
                </button>
            </div>
            
            <div class="canvas-area">
                <div class="canvas" id="canvas">
                    <div class="canvas-label" id="canvas-label">
                        <i class="material-icons" style="font-size: 36px; margin-bottom: 10px;">backup</i><br>
                        Drag blocks here to build numbers!
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        let blockIdCounter = 0;
let draggedBlock = null;
let canvasBlocks = [];
let currentDifficulty = 'tens';
let lastTapTime = 0;
let isDragging = false;
let touchOffset = { x: 0, y: 0 };
let dragStartTime = 0;
let zoomLevel = 1;
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 2;
const ZOOM_STEP = 0.1;
const DOUBLE_TAP_DELAY = 300;
const DRAG_THRESHOLD = 5;
const ANIMATION_DURATION = 200;

// Initialize the app
document.addEventListener('DOMContentLoaded', function() {
  initializeAppWithZoom();
});

function initializeApp() {
  updateDifficultyDisplay();
  setupEventListeners();
  setupDragAndDrop();
  updatePlaceValueDisplay();
}

function setupEventListeners() {
  // Difficulty selector
  const difficultySelect = document.getElementById('difficulty');
  if (difficultySelect) {
    difficultySelect.addEventListener('change', updateDifficultyDisplay);
  }
  
  // Block addition buttons
  const blockButtons = [
    { id: 'add-units', type: 'unit' },
    { id: 'add-tens', type: 'ten' },
    { id: 'add-hundreds', type: 'hundred' },
    { id: 'add-thousands', type: 'thousand' }
  ];
  
  blockButtons.forEach(({ id, type }) => {
    const button = document.getElementById(id);
    if (button) {
      button.addEventListener('click', () => addBlocks(type));
    }
  });
  
  // Clear button
  const clearBtn = document.getElementById('clear-btn');
  if (clearBtn) {
    clearBtn.addEventListener('click', clearCanvas);
  }
}

function updateDifficultyDisplay() {
  const difficultySelect = document.getElementById('difficulty');
  if (!difficultySelect) return;
  
  currentDifficulty = difficultySelect.value;
  
  // Control visibility based on difficulty
  const controls = [
    { id: 'ten-control', show: true },
    { id: 'hundred-control', show: currentDifficulty !== 'tens' },
    { id: 'thousand-control', show: currentDifficulty === 'thousands' }
  ];
  
  controls.forEach(({ id, show }) => {
    const element = document.getElementById(id);
    if (element) {
      element.style.display = show ? 'block' : 'none';
    }
  });
  
  clearCanvas();
}

function addBlocks(type) {
  const countInput = document.getElementById(type + '-count');
  const count = parseInt(countInput?.value) || 0;
  
  if (count <= 0) return;
  
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  const canvasRect = canvas.getBoundingClientRect();
  const blockWidth = getBlockWidth(type);
  const blockHeight = getBlockHeight(type);
  
  // Calculate safe spawn area
  const maxX = Math.max(0, canvas.offsetWidth - blockWidth);
  const maxY = Math.max(0, canvas.offsetHeight - blockHeight);
  
  // Create blocks with collision avoidance
  for (let i = 0; i < count; i++) {
    const position = findSafePosition(maxX, maxY, blockWidth, blockHeight);
    const block = createBlock(type, position.x, position.y);
    
    if (block) {
      canvas.appendChild(block);
      canvasBlocks.push({
        id: block.id,
        type: type,
        value: getBlockValue(type),
        inCanvas: true
      });
    }
  }
  
  // Reset input
  if (countInput) {
    countInput.value = '1';
  }
  
  updatePlaceValueDisplay();
}

function findSafePosition(maxX, maxY, blockWidth, blockHeight) {
  const attempts = 50;
  
  for (let i = 0; i < attempts; i++) {
    const x = Math.floor(Math.random() * (maxX + 1));
    const y = Math.floor(Math.random() * (maxY + 1));
    
    // Check for overlap with existing blocks
    const hasOverlap = canvasBlocks.some(blockData => {
      const existingBlock = document.getElementById(blockData.id);
      if (!existingBlock) return false;
      
      const existingRect = existingBlock.getBoundingClientRect();
      const newRect = {
        left: x,
        top: y,
        right: x + blockWidth,
        bottom: y + blockHeight
      };
      
      return !(newRect.right < existingRect.left || 
               newRect.left > existingRect.right || 
               newRect.bottom < existingRect.top || 
               newRect.top > existingRect.bottom);
    });
    
    if (!hasOverlap) {
      return { x, y };
    }
  }
  
  // Fallback to random position if no safe spot found
  return {
    x: Math.floor(Math.random() * (maxX + 1)),
    y: Math.floor(Math.random() * (maxY + 1))
  };
}

function createBlock(type, x, y) {
  const block = document.createElement('div');
  block.className = `block ${type}-block`;
  block.id = `block-${blockIdCounter++}`;
  
  // Position and styling
  block.style.left = `${x}px`;
  block.style.top = `${y}px`;
  block.style.position = 'absolute';
  block.style.userSelect = 'none';
  block.style.webkitUserSelect = 'none';
  block.style.touchAction = 'none';
  block.style.cursor = 'move';
  
  // Z-index for proper layering
  const zIndexMap = { unit: 1000, ten: 900, hundred: 800, thousand: 700 };
  block.style.zIndex = zIndexMap[type] + blockIdCounter;
  
  // Special styling for thousand blocks
  if (type === 'thousand') {
    block.innerHTML = `
      <div class="cube-face cube-front">1000</div>
      <div class="cube-face cube-back">1000</div>
      <div class="cube-face cube-right"></div>
      <div class="cube-face cube-left"></div>
      <div class="cube-face cube-top"></div>
      <div class="cube-face cube-bottom"></div>
    `;
  }
  
  // Apply current zoom level to new blocks AFTER content is set
  block.style.transform = `scale(${zoomLevel})`;
  block.style.transformOrigin = 'center center';
  
  // Setup interactions
  setupBlockInteractions(block);
  
  return block;
}

function setupBlockInteractions(block) {
  let touchStartPos = null;
  let hasMoved = false;
  
  // Mouse events
  block.addEventListener('mousedown', handleMouseDown);
  block.addEventListener('dblclick', handleDoubleClick);
  
  // Touch events
  block.addEventListener('touchstart', handleTouchStart, { passive: false });
  block.addEventListener('touchmove', handleTouchMove, { passive: false });
  block.addEventListener('touchend', handleTouchEnd, { passive: false });
  
  function handleMouseDown(e) {
    e.preventDefault();
    startDrag(block, e.clientX, e.clientY);
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }
  
  function handleMouseMove(e) {
    if (draggedBlock === block) {
      moveDraggedBlock(e.clientX, e.clientY);
    }
  }
  
  function handleMouseUp() {
    endDrag();
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  }
  
  function handleDoubleClick(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!isDragging) {
      deleteBlock(block);
    }
  }
  
  function handleTouchStart(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const touch = e.touches[0];
    touchStartPos = { x: touch.clientX, y: touch.clientY };
    hasMoved = false;
    dragStartTime = Date.now();
    
    const rect = block.getBoundingClientRect();
    touchOffset.x = touch.clientX - rect.left;
    touchOffset.y = touch.clientY - rect.top;
  }
  
  function handleTouchMove(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!touchStartPos) return;
    
    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - touchStartPos.x);
    const deltaY = Math.abs(touch.clientY - touchStartPos.y);
    
    if (!hasMoved && (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD)) {
      hasMoved = true;
      startDrag(block, touch.clientX, touch.clientY);
    }
    
    if (hasMoved && draggedBlock === block) {
      moveDraggedBlock(touch.clientX, touch.clientY);
    }
  }
  
  function handleTouchEnd(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!hasMoved && touchStartPos) {
      // Handle tap for deletion
      const currentTime = Date.now();
      const timeSinceLastTap = currentTime - lastTapTime;
      
      if (timeSinceLastTap < DOUBLE_TAP_DELAY && timeSinceLastTap > 0) {
        deleteBlock(block);
      }
      
      lastTapTime = currentTime;
    }
    
    endDrag();
    touchStartPos = null;
    hasMoved = false;
  }
}

function startDrag(block, clientX, clientY) {
  draggedBlock = block;
  isDragging = true;
  block.classList.add('dragging');
  block.style.zIndex = 9999;
  
  const canvas = document.getElementById('canvas');
  const canvasRect = canvas.getBoundingClientRect();
  
  if (!touchOffset.x && !touchOffset.y) {
    const rect = block.getBoundingClientRect();
    touchOffset.x = clientX - rect.left;
    touchOffset.y = clientY - rect.top;
  }
}

function moveDraggedBlock(clientX, clientY) {
  if (!draggedBlock) return;
  
  const canvas = document.getElementById('canvas');
  const canvasRect = canvas.getBoundingClientRect();
  
  const x = clientX - canvasRect.left - touchOffset.x;
  const y = clientY - canvasRect.top - touchOffset.y;
  
  // Constrain to canvas bounds
  const constrainedX = Math.max(0, Math.min(x, canvas.offsetWidth - draggedBlock.offsetWidth));
  const constrainedY = Math.max(0, Math.min(y, canvas.offsetHeight - draggedBlock.offsetHeight));
  
  draggedBlock.style.left = constrainedX + 'px';
  draggedBlock.style.top = constrainedY + 'px';
}

function endDrag() {
  if (draggedBlock) {
    draggedBlock.classList.remove('dragging');
    
    // Reset z-index
    const zIndexMap = { unit: 1000, ten: 900, hundred: 800, thousand: 700 };
    const blockType = draggedBlock.className.split(' ')[1].replace('-block', '');
    const blockId = parseInt(draggedBlock.id.split('-')[1]);
    draggedBlock.style.zIndex = zIndexMap[blockType] + blockId;
    
    updatePlaceValueDisplay();
  }
  
  draggedBlock = null;
  isDragging = false;
  touchOffset = { x: 0, y: 0 };
}

function deleteBlock(block) {
  if (!block) return;
  
  block.classList.add('deleting');
  block.style.pointerEvents = 'none';
  
  setTimeout(() => {
    block.remove();
    canvasBlocks = canvasBlocks.filter(b => b.id !== block.id);
    updatePlaceValueDisplay();
  }, ANIMATION_DURATION);
}

function setupDragAndDrop() {
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  canvas.addEventListener('dragover', function(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  });
  
  canvas.addEventListener('drop', function(e) {
    e.preventDefault();
    updatePlaceValueDisplay();
  });
}

function updatePlaceValueDisplay() {
  const counts = { unit: 0, ten: 0, hundred: 0, thousand: 0 };
  
  // Count blocks currently in the canvas
  canvasBlocks.forEach(block => {
    if (block.inCanvas && document.getElementById(block.id)) {
      counts[block.type]++;
    }
  });
  
  // Update breakdown display with regroup buttons
  const breakdown = document.getElementById('value-breakdown');
  if (breakdown) {
    breakdown.innerHTML = `
      <div class="value-row">
        <span><i class="material-icons">crop_square</i> Units: ${counts.unit}</span>
        ${counts.unit >= 10 ? '<button class="regroup-btn" onclick="regroupBlocks(\'unit\')">Regroup</button>' : ''}
      </div>
      <div class="value-row">
        <span><i class="material-icons">more_horiz</i> Tens: ${counts.ten}</span>
        ${counts.ten >= 10 ? '<button class="regroup-btn" onclick="regroupBlocks(\'ten\')">Regroup</button>' : ''}
      </div>
      <div class="value-row">
        <span><i class="material-icons">grid_on</i> Hundreds: ${counts.hundred}</span>
        ${counts.hundred >= 10 ? '<button class="regroup-btn" onclick="regroupBlocks(\'hundred\')">Regroup</button>' : ''}
      </div>
      <div class="value-row">
        <span><i class="material-icons">layers</i> Thousands: ${counts.thousand}</span>
      </div>
    `;
  }
  
  // Calculate and display total value
  const total = (counts.unit * 1) + (counts.ten * 10) + (counts.hundred * 100) + (counts.thousand * 1000);
  const totalValueElement = document.getElementById('total-value');
  if (totalValueElement) {
    totalValueElement.textContent = `Total: ${total.toLocaleString()}`;
  }
  
  // Update canvas label visibility
  const canvasLabel = document.getElementById('canvas-label');
  if (canvasLabel) {
    const hasBlocks = canvasBlocks.some(block => block.inCanvas && document.getElementById(block.id));
    canvasLabel.style.display = hasBlocks ? 'none' : 'block';
  }
}

function clearCanvas() {
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  const blocks = canvas.querySelectorAll('.block');
  blocks.forEach(block => {
    block.classList.add('deleting');
    setTimeout(() => block.remove(), ANIMATION_DURATION);
  });
  
  canvasBlocks = [];
  setTimeout(() => updatePlaceValueDisplay(), ANIMATION_DURATION);
}

function getBlockWidth(type) {
  const widths = { unit: 30, ten: 200, hundred: 200, thousand: 220 };
  return widths[type] || 30;
}

function getBlockHeight(type) {
  const heights = { unit: 30, ten: 30, hundred: 200, thousand: 220 };
  return heights[type] || 30;
}

function getBlockValue(type) {
  const values = { unit: 1, ten: 10, hundred: 100, thousand: 1000 };
  return values[type] || 1;
}

let updateTimeout;
function debouncedUpdate() {
  clearTimeout(updateTimeout);
  updateTimeout = setTimeout(updatePlaceValueDisplay, 16); // ~60fps
}

function regroupBlocks(type) {
  const counts = { unit: 0, ten: 0, hundred: 0, thousand: 0 };
  
  // Count blocks currently in the canvas
  canvasBlocks.forEach(block => {
    if (block.inCanvas && document.getElementById(block.id)) {
      counts[block.type]++;
    }
  });
  
  // Determine how many groups we can make
  let groups = 0;
  let blocksToRemove = 0;
  let newBlockType = '';
  
  switch (type) {
    case 'unit':
      if (counts.unit >= 10) {
        groups = Math.floor(counts.unit / 10);
        blocksToRemove = groups * 10;
        newBlockType = 'ten';
      }
      break;
    case 'ten':
      if (counts.ten >= 10) {
        groups = Math.floor(counts.ten / 10);
        blocksToRemove = groups * 10;
        newBlockType = 'hundred';
      }
      break;
    case 'hundred':
      if (counts.hundred >= 10) {
        groups = Math.floor(counts.hundred / 10);
        blocksToRemove = groups * 10;
        newBlockType = 'thousand';
      }
      break;
  }
  
  if (groups === 0) return;
  
  // Remove the old blocks
  const blocksToDelete = [];
  for (let i = canvasBlocks.length - 1; i >= 0 && blocksToRemove > 0; i--) {
    const blockData = canvasBlocks[i];
    if (blockData.type === type && blockData.inCanvas) {
      const blockElement = document.getElementById(blockData.id);
      if (blockElement) {
        blocksToDelete.push(blockElement);
        blocksToRemove--;
      }
    }
  }
  
  // Animate deletion of old blocks
  blocksToDelete.forEach(block => {
    block.classList.add('regrouping');
    setTimeout(() => {
      block.remove();
      canvasBlocks = canvasBlocks.filter(b => b.id !== block.id);
    }, ANIMATION_DURATION);
  });
  
  // Add new blocks after animation completes
  setTimeout(() => {
    for (let i = 0; i < groups; i++) {
      const canvas = document.getElementById('canvas');
      const canvasRect = canvas.getBoundingClientRect();
      const blockWidth = getBlockWidth(newBlockType);
      const blockHeight = getBlockHeight(newBlockType);
      
      const position = findSafePosition(
        canvas.offsetWidth - blockWidth,
        canvas.offsetHeight - blockHeight,
        blockWidth,
        blockHeight
      );
      
      const block = createBlock(newBlockType, position.x, position.y);
      if (block) {
        block.classList.add('regrouping');
        canvas.appendChild(block);
        
        // Remove the animation class after it completes
        setTimeout(() => {
          block.classList.remove('regrouping');
        }, ANIMATION_DURATION);
        
        canvasBlocks.push({
          id: block.id,
          type: newBlockType,
          value: getBlockValue(newBlockType),
          inCanvas: true
        });
      }
    }
    
    updatePlaceValueDisplay();
  }, ANIMATION_DURATION);
}

function addZoomControls() {
  const zoomControlsHTML = `
    <div class="zoom-controls">
      <h4><i class="material-icons">zoom_in</i> Zoom Controls</h4>
      <div class="zoom-buttons">
        <button class="zoom-btn" onclick="zoomOut()">
          <i class="material-icons">zoom_out</i> 
        </button>
        <span class="zoom-level" id="zoom-level">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">
          <i class="material-icons">zoom_in</i> 
        </button>
      </div>
      <button class="zoom-btn" onclick="resetZoom()">
        <i class="material-icons">center_focus_weak</i> 
      </button>
    </div>
  `;
  
  const placeValueDisplay = document.querySelector('.place-value-display');
  if (placeValueDisplay) {
    placeValueDisplay.insertAdjacentHTML('afterend', zoomControlsHTML);
  }
}

// Zoom in function
function zoomIn() {
  if (zoomLevel < MAX_ZOOM) {
    zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
    applyZoom();
  }
}

// Zoom out function
function zoomOut() {
  if (zoomLevel > MIN_ZOOM) {
    zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
    applyZoom();
  }
}

// Reset zoom function
function resetZoom() {
  zoomLevel = 1;
  applyZoom();
}

function applyZoom() {
  const canvas = document.getElementById('canvas');
  if (!canvas) return;
  
  // Apply zoom to all existing blocks
  const blocks = canvas.querySelectorAll('.block');
  blocks.forEach(block => {
    // Apply the transform directly to the block
    block.style.transform = `scale(${zoomLevel})`;
    block.style.transformOrigin = 'center center';
    
    // For thousand blocks, ensure the cube faces are also properly scaled
    if (block.classList.contains('thousand-block')) {
      const cubeFaces = block.querySelectorAll('.cube-face');
      cubeFaces.forEach(face => {
        // Reset any individual transforms on cube faces
        face.style.transform = '';
      });
    }
  });
  
  // Update zoom level display
  const zoomLevelElement = document.getElementById('zoom-level');
  if (zoomLevelElement) {
    zoomLevelElement.textContent = `${Math.round(zoomLevel * 100)}%`;
  }
  
  updateZoomButtonStates();
}

function initializeAppWithZoom() {
  initializeApp();
  addZoomControls();
  updateZoomButtonStates();
}

function updateZoomButtonStates() {
  const zoomButtons = document.querySelectorAll('.zoom-btn');
  if (zoomButtons.length >= 2) {
    const zoomOutBtn = zoomButtons[0];
    const zoomInBtn = zoomButtons[1];
    
    if (zoomOutBtn) {
      zoomOutBtn.disabled = zoomLevel <= MIN_ZOOM;
    }
    
    if (zoomInBtn) {
      zoomInBtn.disabled = zoomLevel >= MAX_ZOOM;
    }
  }
}


    </script>
</body>

</html>